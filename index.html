<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <title>How to make a shoot'Em up with Quintus - Part 2</title>
    <style>
        body {
            padding: 0;
            margin: 0;
            background: #fff;
        }
        canvas {
            background: #000;
        }
    </style>
</head>
<body>

    <!-- Loading quintus and all its modules -->
    <script src="js/quintus.js"></script>
    <script src="js/quintus_2d.js"></script>
    <script src="js/quintus_anim.js"></script>
    <script src="js/quintus_audio.js"></script>
    <script src="js/quintus_input.js"></script>
    <script src="js/quintus_scenes.js"></script>
    <script src="js/quintus_sprites.js"></script>
    <script src="js/quintus_tmx.js"></script>
    <script src="js/quintus_touch.js"></script>

    <script>
        window.addEventListener("load", function() {
            var Q = Quintus({ development: true })
            /**
             * In Part 2, I'm going to need Input module for keyboardControls.
             */
            .include("Sprites, Scenes, 2D, Input")
            .setup({ width: 320, height: 480 })
            /**
             * With this single line, controls are now activated.
             */
            .controls();

            Q.gravityY = 0;

            var SPRITE_PLAYER = 1;
            var SPRITE_BULLET = 2;
            var SPRITE_ENEMY  = 3;

            Q.MovingSprite.extend("Player", {
                init: function(p) {
                    this._super(p, {
                        sheet: "player",
                        sprite: "player",
                        type: SPRITE_PLAYER,
                        collisionMask: SPRITE_ENEMY,
                        /**
                         * "speed" is the speed of the player when it's moving.
                         */
                        speed: 300
                    });

                    /**
                     * When the player push "FIRE" button, Quintus fires the "fire" event
                     * and the method "shoot" is called.
                     */
                    Q.input.on("fire", this, "shoot");
                },

                /**
                 * Override the "step" method to define what to do when LEFT or RIGHT keys
                 * are pushed. I increment or decrement the vx with speed and then update x.
                 */
                step: function(dt) {
                    var p = this.p;
                    /**
                     * Checking if LEFT key is pushed and if the left wing of player is inside canvas.
                     */
                    if (Q.inputs['left'] && (p.x - p.w/2) > 0) {
                        p.vx = -p.speed;
                    /**
                     * Checking if RIGHT key is pushed and if the right wing of player is inside canvas.
                     */
                    } else if (Q.inputs['right'] && (p.x + p.w/2) < Q.width) {
                        p.vx = p.speed;
                    } else {
                        p.vx = 0;
                    }

                    p.x  += p.vx * dt;
                },

                /**
                 * This method will create a new object Bullet.
                 * The position of new Bullet has to be the same x as the player and
                 * a little above from the player object.
                 * vy is the speed of Bullet on y edge.
                 */
                shoot: function() {
                    var p = this.p;
                    this.stage.insert(new Q.Bullet({
                        x: p.x,
                        y: p.y - p.w/2,
                        vy: -200
                    }))
                }
            });

            Q.MovingSprite.extend("Enemy", {
                init: function(p) {
                    this._super(p, {
                        sheet: "enemy",
                        sprite: "enemy",
                        type: SPRITE_ENEMY,
                        collisionMask: SPRITE_BULLET | SPRITE_PLAYER,
                        /**
                         * This flag disable the impact implemented by Quintus.
                         * My Enemy objects are not stopping now when they collide itself.
                         */
                        skipCollide: true
                    });
                    this.add("2d");

                    /**
                     * I add a listener so I can manage collisions.
                     */
                    this.on("hit");
                },

                hit: function(col) {
                    /**
                     * If "Enemy" collides with the "Player", "Enemy" dies.
                     */
                    if (col.obj.isA("Player")) {
                        this.destroy();
                    }
                    /**
                     * If "Enemy" collides with a "Bullet", they die.
                     */
                    else if (col.obj.isA("Bullet")) {
                        this.destroy();
                        col.obj.destroy();
                    }
                }
            });

            /**
             * I'm going to create a new object "Bullet" extending "MovingSprite".
             * The default properties are:
             * - Use the sprite "bullet".
             * - The type is SPRITE_BULLET.
             * - Collides with SPRITE_ENEMY.
             * - sensor is true because I want to define my own behavior when it collides.
             */
            Q.MovingSprite.extend("Bullet", {
                init: function(p) {
                    this._super(p, {
                        sheet: "bullet",
                        sprite: "bullet",
                        type: SPRITE_BULLET,
                        collisionMask: SPRITE_ENEMY,
                        sensor: true
                    });

                    /**
                     * Adding 2d component to activate collisions detection and movement.
                     */
                    this.add("2d");
                },

                /**
                 * I'm overriding step method to destroy bullets.
                 * Every bullet outside the canvas should be destroyed. If I don't destroy
                 * them, the bullet is still alive and can kill enemies outside canvas where
                 * the player cannot see anything.
                 */
                step: function(dt) {
                    if (this.p.y < 0) {
                        this.destroy();
                    }
                }
            })

            Q.scene("level1", function(stage) {
                var player = stage.insert(new Q.Player({
                    x: Q.width/2,
                    y: Q.height - 20
                }));

                var num_enemies = Math.floor(Math.random() * 10 + 30);
                var enemies = new Array(num_enemies);
                /**
                 * Some enemies were displayed outside the canvas. So I change
                 * this code to display enemies on edge X betwen 30px and 290px (Q.width-30).
                 */
                var minX = 30;
                var maxX = Q.width - 30;
                for (var i=0; i <= num_enemies; i++) {
                    enemies.push(stage.insert(new Q.Enemy({
                        x: Math.floor(Math.random() * (maxX - minX + 1)) + minX,
                        y: -(Math.random() * 50) - (100*i),
                        vy: Math.random() * 75 + 100
                    })));
                }
            });

            Q.load("sprites.png, sprites.json", function() {
                Q.compileSheets("sprites.png", "sprites.json");
                Q.stageScene("level1");
            });
        });
    </script>
</body>
</html>